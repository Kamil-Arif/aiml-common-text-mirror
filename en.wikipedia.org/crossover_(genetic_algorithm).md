In genetic algorithms and evolutionary computation, crossover, also
called recombination, is a genetic operator used to combine the genetic
information of two parents to generate new offspring. It is one way to
stochastically generate new solutions from an existing population, and
is analogous to the crossover that happens during sexual reproduction in
biology. Solutions can also be generated by cloning an existing
solution, which is analogous to asexual reproduction. Newly generated
solutions are typically mutated before being added to the population.
Different algorithms in evolutionary computation may use different data
structures to store genetic information, and each genetic representation
can be recombined with different crossover operators. Typical data
structures that can be recombined with crossover are bit arrays, vectors
of real numbers, or trees. Crossover for different genetic
representations The list of operators presented below is by no means
complete and serves mainly as an exemplary illustration of this dyadic
genetic operator type. More operators and more details can be found in
the literature. Crossover for binary arrays Traditional genetic
algorithms store genetic information in a chromosome represented by a
bit array. Crossover methods for bit arrays are popular and an
illustrative example of genetic recombination. One-point crossover A
point on both parents\' chromosomes is picked randomly, and designated a
\'crossover point\'. Bits to the right of that point are swapped between
the two parent chromosomes. This results in two offspring, each carrying
some genetic information from both parents. Two-point and k-point
crossover In two-point crossover, two crossover points are picked
randomly from the parent chromosomes. The bits in between the two points
are swapped between the parent organisms. Two-point crossover is
equivalent to performing two single-point crossovers with different
crossover points. This strategy can be generalized to k-point crossover
for any positive integer k, picking k crossover points. Uniform
crossover In uniform crossover, typically, each bit is chosen from
either parent with equal probability. Other mixing ratios are sometimes
used, resulting in offspring which inherit more genetic information from
one parent than the other. In a uniform crossover, we don't divide the
chromosome into segments, rather we treat each gene separately. In this,
we essentially flip a coin for each chromosome to decide whether or not
it'll be included in the off-spring. We can also bias the coin to one
parent, to have more genetic material in the child from that parent.
Crossover for integer or real-valued genomes For the crossover operators
presented above and for most other crossover operators for bit strings,
it holds that they can also be applied accordingly to integer or
real-valued genomes whose genes each consist of an integer or
real-valued number. Instead of individual bits, integer or real-valued
numbers are then simply copied into the child genome. The offspring lie
on the remaining corners of the hyperbody spanned by the two parents P 1
= ( 1.5 , 6 , 8 ) {\\displaystyle P\_{1}=(1.5,6,8)} and P 2 = ( 7 , 2 ,
1 ) {\\displaystyle P\_{2}=(7,2,1)} , as exemplified in the accompanying
image for the three-dimensional case. Discrete recombination If the
rules of the uniform crossover for bit strings are applied during the
generation of the offspring, this is also called discrete recombination.
Intermediate recombination In this recombination operator, the allele
values of the child genome a i {\\displaystyle a\_{i}} are generated by
mixing the alleles of the two parent genomes a i , P 1 {\\displaystyle
a\_{i,P\_{1}}} and a i , P 2 {\\displaystyle a\_{i,P\_{2}}} : α i = α i
, E 1 ⋅ β i + α i , E 2 ⋅ ( 1 − β i ) w i t h β i ∈ \[ − d , 1 + d \]
{\\displaystyle \\alpha \_{i}=\\alpha \_{i,E\_{1}}\\cdot \\beta
\_{i}+\\alpha \_{i,E\_{2}}\\cdot \\left(1-\\beta \_{i}\\right)\\quad
{\\mathsf {with}}\\quad \\beta \_{i}\\in \\left\[-d,1+d\\right\]}
randomly equally distributed per gene i {\\displaystyle i} The choice of
the interval \[ − d , 1 + d \] {\\displaystyle \[-d,1+d\]} causes that
besides the interior of the hyperbody spanned by the allele values of
the parent genes additionally a certain environment for the range of
values of the offspring is in question. A value of 0.25 {\\displaystyle
0.25} is recommended for d {\\displaystyle d} to counteract the tendency
to reduce the allele values that otherwise exists at d = 0
{\\displaystyle d=0} .The adjacent figure shows for the two-dimensional
case the range of possible new alleles of the two exemplary parents P 1
= ( 2 , 6 ) {\\displaystyle P\_{1}=(2,6)} and P 2 = ( 9 , 2 )
{\\displaystyle P\_{2}=(9,2)} in intermediate recombination. The
offspring of discrete recombination C 1 {\\displaystyle C\_{1}} and C 2
{\\displaystyle C\_{2}} are also plotted. Intermediate recombination
satisfies the arithmetic calculation of the allele values of the child
genome required by virtual alphabet theory. Discrete and intermediate
recombination are used as a standard in the evolution strategy.
Crossover for permutations For combinatorial tasks, permutations are
usually used that are specifically designed for genomes that are
themselves permutations of a set. The underlying set is usually a subset
of N {\\displaystyle \\mathbb {N} } or N 0 {\\displaystyle \\mathbb {N}
\_{0}} . If 1- or n-point or uniform crossover for integer genomes is
used for such genomes, a child genome may contain some values twice and
others may be missing. This can be remedied by genetic repair, e.g. by
replacing the redundant genes in positional fidelity for missing ones
from the other child genome. In order to avoid the generation of invalid
offspring, special crossover operators for permutations have been
developed which fulfill the basic requirements of such operators for
permutations, namely that all elements of the initial permutation are
also present in the new one and only the order is changed. It can be
distinguished between combinatorial tasks, where all sequences are
admissible, and those where there are constraints in the form of
inadmissible partial sequences. A well-known representative of the first
task type is the traveling salesman problem (TSP), where the goal is to
visit a set of cities exactly once on the shortest tour. An example of
the constrained task type is the scheduling of multiple workflows.
Workflows involve sequence constraints on some of the individual work
steps. For example, a thread cannot be cut until the corresponding hole
has been drilled in a workpiece. Such problems are also called
order-based permutations. In the following, two crossover operators are
presented as examples, the partially mapped crossover (PMX) motivated by
the TSP and the order crossover (OX1) designed for order-based
permutations. A second offspring can be produced in each case by
exchanging the parent chromosomes. Partially mapped crossover (PMX) The
PMX operator was designed as a recombination operator for TSP like
Problems. The explanation of the procedure is illustrated by an example:
Order crossover (OX1) The order crossover goes back to Davis in its
original form and is presented here in a slightly generalized version
with more than two crossover points. It transfers information about the
relative order from the second parent to the offspring. First, the
number and position of the crossover points are determined randomly. The
resulting gene sequences are then processed as described below: Among
other things, order crossover is well suited for scheduling multiple
workflows, when used in conjunction with 1- and n-point crossover.
Further crossover operators for permutations Over time, a large number
of crossover operators for permutations have been proposed, so the
following list is only a small selection. For more information, the
reader is referred to the literature. cycle crossover (CX) order-based
crossover (OX2) position-based crossover (POS) edge recombination voting
recombination (VR) alternating-positions crossover (AP) maximal
preservative crossover (MPX) merge crossover (MX) sequential
constructive crossover operator (SCX)The usual approach to solving
TSP-like problems by genetic or, more generally, evolutionary
algorithms, presented earlier, is either to repair illegal descendants
or to adjust the operators appropriately so that illegal offspring do
not arise in the first place. Alternatively, Riazi suggests the use of a
double chromosome representation, which avoids illegal offspring. See
also Evolutionary computation Evolutionary algorithm Genetic algorithm
Chromosome (genetic algorithm) Genetic representation Mutation (genetic
algorithm) Fitness approximation Fitness function Selection (genetic
algorithm) Bibliography John Holland (1975). Adaptation in Natural and
Artificial Systems, PhD thesis, University of Michigan Press, Ann Arbor,
Michigan. ISBN 0-262-58111-6. Schwefel, Hans-Paul (1995). Evolution and
Optimum Seeking. New York: John Wiley & Sons. ISBN 0-471-57148-2. Davis,
Lawrence (1991). Handbook of genetic algorithms. New York: Van Nostrand
Reinhold. ISBN 0-442-00173-8. OCLC 23081440. Eiben, A.E.; Smith, J.E.
(2015). Introduction to Evolutionary Computing. Natural Computing
Series. Berlin, Heidelberg: Springer. doi:10.1007/978-3-662-44874-8.
ISBN 978-3-662-44873-1. Yu, Xinjie; Gen, Mitsuo (2010). Introduction to
Evolutionary Algorithms. Decision Engineering. London: Springer.
doi:10.1007/978-1-84996-129-5. ISBN 978-1-84996-128-8. Bäck, Thomas;
Fogel, David B.; Michalewicz, Zbigniew, eds. (1999). Evolutionary
computation. Vol. 1, Basic algorithms and operators. Bristol: Institute
of Physics Pub. ISBN 0-585-30560-9. OCLC 45730387. References External
links Newsgroup: comp.ai.genetic FAQ - see section on crossover (also
known as recombination).
